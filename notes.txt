JSX
 * JavaScript XML (JSX) - extension to the javascript language syntax
 * write xml like code for elements and components
 * jsx tags have: tagname, attributes and children
 * jsx is not a necessity to write react application
 * jsx makes your react code simple and elegant
 * jsx ultimately transpiles to pure JavaScript which is understood by the browser
 * Differences:
 *  class ==. className
 *  for ==> htmlFor
 *  onclick ==> onClick
 *  tabindex ==> tabIndex
 *  etc
 Demo example: JSX.js
 *********************************************************************
 props vx state
 props
  1. they get passed to the component
  2. they are immutable
  3. props ----> functional component or this.props ---> class component
  4. can be considered as function parameters

state
 1. managed within the component
 2. can be changed
 3. useStat Hook ---> functional component or this.state ---> class component
 4. can be considred as local variables of a function

 Example: Message.js
 *********************************************************************

 setState
  1. Always make use of the the set state and never modify state directly
  2. Code has to be executed after the state  has been executed? place the code in a callback function which is the second argument to the setState method
  3. When you have to update state based on the previous state value, pass in a function as an argument instead of the regular object

  Demo example: Counter.js
  ********************************************************************

  Destructuring: It is a feature of ES6 which enables us to unpack values from arrays or properties from objects into distinct variables. In react destructuring improves code readability
  Ex. Hello.js and Welcome.js
  ********************************************************************
  Event binding
    It is neccessary to bind events because this is undefined if we do do the same. This is JavaScript behaviour and not React specific.
    In React event binding can happend in different ways:
      1. Using bind keyword and bind the event handler in the render  
         method. 
         * Now, if console log the this keyword it will no longer be undefined rather it will point to the component instance.
         * This approach has some performance implication on large systems with lots of nested children components because as the state changes the render() is called. And it creates a new event handler on each re-render.

      2. To use arrow functions in the render() method. This approach also has the same problem as the first.

      3. Binding the event handler in the constructor as opposed binding in the render() method; it is what you see in the official React documentation. Since the binding happer in the constructor method this is better than the render method approach.

      4. Using arrow functions in a class property.

      summary: First approach is something you would never want to use. Although appoach 2 is similar to 1ˢᵗ one, it is by far the easiest way to pass parameters. React documentation suggests 3 or 4; and as approach 4 is experienmental feature it is suggested to use 3ʳᵈ.
      create-react supports the 4ᵗʰ and very soon it will be the go-to approach.

      Example: EventBinding.js
  *************************************************************************************************
  Method as props
  Parent.js and Child.js
  ********************************************************************
  *****************************
  Conditional Rendering: There are four approaches
    1. if/else 
    2. Element variables
      let message = this.state.isLoggedin ? "Welcome Temesghen" : "Welcome Guest"
    return (
      <div>
        <h1>{message}</h1>
      </div>
    )
    3. Ternary conditional operator: keeps the code simple and readable
      return(
        this.state.isLoggedin ? <h1>Welcome Temesghen</h1> : <h1>Welcome Guest</h1>
      )
    4. Short circuit operator
       return(
      this.state.isLoggedin && <h1>Welcome Temesghen</h1>
    )
    example: ConditionalRendering.js
**********************************************************************
List Rendering: 
**********************************
  - A key is a special string you need to include when creating lists of elements
  - It gives an element a stable identiy

  - Every list element must have a key
  - It is used by React to track changes for DOM update and it helps for the UI to be updated efficiently
  - key is not a prop and cannot be modified.

  example: ListRendering.js
**********************************************************************
Index As a Key as Anti Pattern
When to use index as a key:
  1. the items in your list do not have a unique identiy
  2. the list is a static and will never change
  3. the list will never be reordered or filtered
You can use one of the npm packages that generates a list or you can use hashing value existing value from one of the existing properties
********************************************************************
Styling React components
************************
1. CSS Stylesheet: we can use backticks for multiple classes
  ex. Stylesheets.js
2. Inline Styling: ex. Inline.js
3. CSS Modules: classes are locally scoped by default. Normal css file applies to child elements and it can lead to css confilict.  
4. CSS In JS Libraries
********************************************************************
Controlled React component
 steps
  1. create a component state that controls the value of the input element
  2. Assign the value of the component to the state
  3. Handle the onchange event on the component

<button type="submit">Submit</button>: type="submit" allows us to submit the page by pressing the enter key

If you don't have a form you can submit the form attaching the onSubmit event to the button.
Example: Form.js
**********************************************************************

Life Cycle methods: 
  mounting: 
    - when winstance of a component is being created or inserted into the DOM
    - methods: constructor, static getDerivedStateFromProps, render and componentDidMount
  
  updating: 
    - when a component is being re-rendered as a result of changes to its props or state
    - methods: getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, and componentDidUpdate 
  
  unmounting: 
    - when a component is being removed from the DOM 
    - methods: componentWillUnmount
  
  error handling:
    - when there is an error in rendering, in a life cycle method or costructor of any child component
    - static getDerivedStateFromErrors and componentDidCatch

  Mounting LifeCycle Methods
    - Methods called when instance of a component is being created or inserted into the DOM
    - Methods in order:
    1. Constructor 
      - constructor(props) - a special fuction called whenever a new component is being created
      - used:
         - Initialize state
         - binding event handlers
      - not used for: side effects. Ex. HTTP request
      - other important points:
        - super(props): call base class constructor
        - we can use this.state directly
    
    2. static getDerivedStateFromProps(porps, state)
      - rarely used LifeCycle method
      - when the state of a component depends on changes in props over time
      - as it is a static method this keyword cannot be used, to set the state you just need to return an object representing the new state
      - don't use side effects

    3. render()
      - only required method in a class component
      - read props and state and return the JSX that represents the UI
      - pure function, for a given props and state it should always render the same UI
      -DO NOT change the state of the state or intereact with DOM or make ajax calls.
      - since it contains children objects, the lifecycle methods are also executed.
    4. componentDidMount()
      - the last LifeCycle method during mounting phase
      - called once during the lifecycle of the whole component
      - invoded immeditely after a component and all its children components have been rendered to the DOM
      - it is the perfect method to cause side effects. Ex. intereact with the DOM or perform ajax call to load data

  Updating LifeCycle Methods
    1. static getDerivedStateFromProps(porps, state)
      - method is called every time a component is re-rendered
      - set state
      - no side effects
      - rarely used 
    2. shouldComponentUpdate(nextPros, nextState)
      - can prevent defualt behaviour by returning false
      - performance optimization
      - don't cause side effects or call setState() method
      - rarely used
    3. render(): avoid side effects or intereacting with the DOM
    4. getSnapshotBeforeUpdate(prevPorps, prevState)
      - called right before the changes from virtual DOM are to be reflected in the DOM
      - capture some info from the DOM. Ex. read user scroll position and after the update maintain that scroll position by performing some calculation
      - return null or a value and the value will be passed as the third parameter to the next phase

    5. componentDidUpdate(prevPorps, prevState, snapshot)
      - called after the render is finished in the re-render cycle
      - guarented to be called only once in each re-render cycle
      - cause side effects but you need to compare the prevState with the newState
      - if not you are making unwanted requests

  Unmounting phase
    -componentWillUnmount() => method invoked immediately before a component is unmounted and destroyed
    - clean up tasks
      - cancelling any network request
      - removing event handlers
      - cancelling subsriptions 
      - invading timers
    - don't calls setState

  Error handling Methods
    - when there is an error in rendering, in a life cycle method or costructor of any child component
    - static getDerivedStateFromErrors and componentDidCatch
********************************************************************
Fragments
  - Fragments let you group a list of children without adding extra nodes to the DOM. example FragmentDemo.js
  - A common pattern is for a component to return a list of children. Take this example React snippet. Ex. Table.js and Column.js
  - Short Syntax <> </>
  - Fragments declared with the explicit <React.Fragment> syntax may have keys. A use case for this is mapping a collection to an array of fragments
  - key is the only attribute that can be passed to Fragment

